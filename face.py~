#test
import cv2
import numpy as np
import math

Lx=200
Ly=30
h=210
Rx=Lx+h
Ry=Ly+h
boxx=(Rx-Lx)//3
boxy=(Ry-Ly)//3
dx=(Rx-Lx)//12
dy=(Ry-Ly)//12
imgs=[[None, None, None]]*3 #cell images
c_colors=[[None, None, None]]*3 #cell colors
#cells=[[None, None, None]]*3 #cell locations
#cells=[[Lx+e*boxx+dx, Lx+(e+1)*boxx-dx, Ly+f*boxy+dy, Ly+(f+1)*boxy-dy] for e in range(3) for f in range(3)]
cells=[]
for e in range(3):
    for f in range(3):
        cells.append([Lx+e*boxx+dx, Lx+(e+1)*boxx-dx, Ly+f*boxy+dy, Ly+(f+1)*boxy-dy])


capture = cv2.VideoCapture(0)
#capture= cv2.VideoCapture("cube4.jpg")
def callback(num):
    return
    
def getcolor(c): # compare rgb values and return color
    r,g,b=c
    if (r >= 118 and r <= 230 ) and (g >= 6 and g <= 100) and (b > 6 and b < 100):
        return 'b'
    elif (r >= 148 and r <= 250 ) and (g >= 140 and g <= 250) and (b >= 140): #(r >= 148 and r <= 250 ) and (g >= 140 and g < 250) and (b >= 140 and b < 250):
        return 'w'
    elif (r >= 21 and r <= 118 ) and (g > 130 and g < 255) and (b > 150 and b < 255):
        return 'y'
    elif (r > 0 and r <= 75 ) and (g >= 79 and g <= 130) and (b > 125 and b < 255):
        return 'o'
    elif (r >= 10 and r <= 70 ) and (g >= 40 and g < 140) and (b >= 90):
        return 'r'
    elif (r >= 40 and r <= 116 ) and (g > 130 and g <= 235) and (b > 80  and b <= 170):
        return 'g'
    else:
        pass
    
def funcRotate(degree=0):
    degree = cv2.getTrackbarPos('degree','Frame')
    rotation_matrix = cv2.getRotationMatrix2D((width / 2, height / 2), degree, 1)
    rotated_image = cv2.warpAffine(original, rotation_matrix, (width, height))
    #cv2.imshow('Rotate', rotated_image)

def getAverageRGBN(image):
  """
  Given PIL Image, return average value of color as (r, g, b)
  """
  # get image as numpy array
  im = np.array(image)
  # get shape
  w,h,d = im.shape
  # change shape
  im.shape = (w*h, d)
  # get average
  return tuple(im.mean(axis=0)) #tuple(np.average(im, axis=0))

cv2.namedWindow('Settings', 0)

#cv2.createTrackbar('Canny Thres 1', 'Settings', 87, 500, callback)
#cv2.createTrackbar('Canny Thres 2', 'Settings', 325, 500, callback)
#cv2.createTrackbar('Blur kSize', 'Settings', 9, 100, callback)
#cv2.createTrackbar('Blur Sigma X', 'Settings', 75, 100, callback)
#cv2.createTrackbar('Dilation Iterations', 'Settings', 2, 20, callback)
#cv2.createTrackbar('Blob Area', 'Settings', 700, 1000, callback)
"""
cv2.createTrackbar('Contour R', 'Settings', 0, 255, callback)
cv2.createTrackbar('Contour G', 'Settings', 0, 255, callback)
cv2.createTrackbar('Contour B', 'Settings', 255, 255, callback)
"""
cv2.createTrackbar('Exposure', 'Settings', 5, 12, callback)
"""
def drawCube(img, cubesize, cubeshape, start_point): # start_poing (100, 60)
    cubecell = int(cubesize / cubeshape)
    # draw horizontal lines first
    for i in range(cubeshape + 1):
        start_line = (start_point[0], start_point[1] + i * cubecell)
        end_line = (start_point[0] + cubesize, start_point[1] + i * cubecell)
        cv2.line(img, start_line, end_line, cubecolor, 2)
    
    for i in range(cubeshape + 1):
        start_line = (start_point[0] + i * cubecell, start_point[1])
        end_line = (start_point[0] + i * cubecell, start_point[1] + cubesize)
        cv2.line(img, start_line, end_line, cubecolor, cubelineSize)

    return img
"""
def regFaces(frame):
    frame2 = frame.copy()
    #drawCube(frame2,180,3,(100,60))  
    
    for e in range(3):
        for f in range(3):
            cv2.line(frame2, (cells[e+3*f][0], cells[e+3*f][2]), (cells[e+3*f][0], cells[e+3*f][3]), (0,0,0), thickness=2)
            cv2.line(frame2, (cells[e+3*f][1], cells[e+3*f][2]), (cells[e+3*f][1], cells[e+3*f][3]), (0,0,0), thickness=2)
            cv2.line(frame2, (cells[e+3*f][0], cells[e+3*f][2]), (cells[e+3*f][1], cells[e+3*f][2]), (0,0,0), thickness=2)
            cv2.line(frame2, (cells[e+3*f][0], cells[e+3*f][3]), (cells[e+3*f][1], cells[e+3*f][3]), (0,0,0), thickness=2)
            imgs[e][f]=frame2[cells[e+3*f][2]:cells[e+3*f][3],cells[e+3*f][0]:cells[e+3*f][1]]
            #ibgr =int(imgs[e][f][(cells[e+3*f][3]-cells[e+3*f][2])//2, (cells[e+3*f][1]-cells[e+3*f][0])//2])
            c_colors[e][f]=getcolor(getAverageRGBN(imgs[e][f]))
            r, g, b = cv2.split(imgs[e][f])
            r_avg = cv2.mean(r)[0]
            g_avg = cv2.mean(g)[0]
            b_avg = cv2.mean(b)[0]
            #c_colors[e][f]=getcolor(int(r_avg),int(g_avg),int(b_avg))
            #cv2.imshow("cropped"+str(e)+str(f)+str([int(r_avg),int(g_avg),int(b_avg)])+"/"+str(c_colors[e][f]), imgs[e][f])
            #cv2.imshow("cropped"+str(e)+str(f)+str([int(r_avg),int(g_avg),int(b_avg)])+"~"+str([r,g,b])+"/"+str(c_colors[e][f]), imgs[e][f])
           
    e=0
    f=0
    ibgr = imgs[e][f][(cells[e+3*f][3]-cells[e+3*f][2])//2, (cells[e+3*f][1]-cells[e+3*f][0])//2]
    #imS = cv2.resize(imgs[e][f], (60, 140)) 
    cv2.imshow("cropped"+str(e)+str(f)+":"+str([int(r_avg),int(g_avg),int(b_avg)])+"/"+str(ibgr)+":"+str(c_colors[e][f]), imgs[e][f])
    """
    e=0
    f=2
    cv2.imshow("cropped"+str(e)+str(f)+"/"+str(c_colors[e][f]), imgs[e][f])
    """
    
    ##pixel_b, pixel_g, pixel_r = cv2.split(img3)
    #pixel_b, pixel_g, pixel_r = img3
    #font = cv2.FONT_HERSHEY_SIMPLEX
    #cv2.putText(frame2,str(pixel_r)+"/"+str(pixel_g)+"/"+str(pixel_b),(10,50), font, 1, (0, 0, 255), 1, cv2.LINE_AA)
    #cv2.imshow("Canny Edge", canny);

    return frame2;

while (capture.isOpened()):
    frame = np.zeros((480,640))
    #frame = np.zeros((240,320))
    #capture= cv2.VideoCapture("cube4.jpg")
    ret, frame = capture.read()
    

    if ret:
        capture.set(cv2.CAP_PROP_EXPOSURE, (cv2.getTrackbarPos('Exposure', 'Settings')+1)*-1)
        newFrame = regFaces(frame);
        #newFrame = cv2.rectangle(newFrame, (20,20), (60,60), (255, 255, 255), -1)
        #cv2.imshow("Webcam Capture", frame);
        cv2.imshow("Faces", newFrame);

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    else:
        break

capture.release()
cv2.destroyAllWindows()
